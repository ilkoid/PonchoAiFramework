# Жёсткие правила фреймворка Poncho

Ниже — набор жёстких архитектурных правил для PonchoAiFramework, которые можно зафиксировать в `ARCHITECTURE_RULES.md` и требовать соблюдения при любом PR. Они опираются на практику Clean Architecture / DDD в Go и типовые рекомендации по однонаправленным зависимостям.[^1][^2][^3]

***

## Базовый принцип

**Единственное направление зависимостей:**
Зависимости всегда идут снаружи внутрь, от более конкретного к более абстрактному:

`cmd / ui / cli` → `flows` → `core (framework, interfaces, prompts)` → `models / tools` → `infra (HTTP, S3, WB)`

Никогда не наоборот.[^3][^4]

***

## Правила по слоям

### 1. Core / Interfaces

- Пакеты `core/*`, `interfaces/*`, `prompts/*`:
    - **Никогда** не импортируют:
        - `tools/*`
        - `models/*`
        - `cli/*`
        - `ui/*`
        - `cmd/*`
    - Содержат только:
        - интерфейсы (`PonchoModel`, `PonchoTool`, `PonchoFlow`, логгер и т.п.),
        - базовые типы и ошибки,
        - фреймворк‑оркестратор и общую конфигурацию.[^5][^1]
- Любая новая функциональность на этом уровне:
    - добавляется через интерфейсы и абстракции,
    - не знает о конкретных провайдерах (DeepSeek, Z.AI, S3, WB и т.д.).


### 2. Models / Tools

- Пакеты `models/*`, `tools/*`:
    - Могут импортировать только:
        - `interfaces/*`
        - `core/*` (где нужны базовые типы),
        - стандартную библиотеку.
    - Не могут импортировать:
        - `cli/*`
        - `ui/*`
        - `flows/*`
        - `cmd/*`.
- Конкретные реализации (DeepSeek, Z.AI, S3, Wildberries):
    - реализуют интерфейсы из `interfaces/*`,
    - не расширяют их «задним числом» через type assertion в верхних слоях.


### 3. Flows / Application Logic

- Пакеты `flows/*`, `cli/articleflow/*`:
    - Могут импортировать:
        - `interfaces/*`, `core/*`,
        - `models/*`, `tools/*` (как зависимости / адаптеры),
        - вспомогательные пакеты (конкурентные утилиты, кеши).
    - Не могут импортировать:
        - `ui/*`,
        - `cmd/*`.
- Вся бизнес‑оркестрация (сценарии обработки артикула, мини‑агенты, пайплайны) живёт здесь.
UI и CLI только вызывают готовые флоу, не содержат логики.[^6][^7]


### 4. CLI / UI / cmd

- Пакеты `cli/*`, `ui/*`, `cmd/*`:
    - Могут импортировать любые внутренние пакеты фреймворка.
    - Никакой функциональности из них не должно быть нужно «внутри»:
        - никакие пакеты не должны импортировать `ui/*` или `cmd/*`.[^4][^8]

***

## Правила для интерфейсов и зависимостей

1. **Интерфейсы объявляются там, где они используются.**
Если `ArticleFlow` использует `WildberriesClient`, интерфейс для него объявляется рядом с `ArticleFlow`, а не в `tools/wildberries`.[^2][^9]
2. **Зависимости внедряются, а не создаются внутри.**
    - Внутри `ArticleFlow`, `SimpleConsoleUI`, любых flows и сервисов:
        - Запрещено вызывать `NewXxxClient()` напрямую по env/config.
        - Все зависимости приходят через конструктор или фабрику (DI на уровне Go‑кода).
3. **Запрещены циклические зависимости между пакетами.**
Любая попытка «обойти» это через копипасту типов или `interface{}` считается архитектурным дефектом, а не просто ошибкой компиляции.[^8][^2][^4]

***

## Правила по состоянию и контексту

1. **Глобальное состояние запрещено.**
    - Никаких глобальных синглтонов с живым состоянием (клиенты, кэши, флоу‑стейт).
    - Допустимы только:
        - конфигурация, загруженная на старте и передаваемая по зависимостям,
        - registry‑объекты внутри фреймворка, защищённые мьютексами.
2. **In‑memory state только per‑запрос / per‑flow.**
    - `FlowContext`, `ArticleFlowState` и аналогичные структуры живут только в рамках одного выполнения сценария и дальше становятся мусором для GC.
    - Запрещено хранить в них большие бинарные данные «навсегда»:
        - изображения и крупные payload’ы должны быть представлены ссылками (пути, URL, ключи S3), а не `[]byte`.
3. **Контекст Go (`context.Context`) обязателен в публичных API.**
    - Все публичные методы:
        - `Generate`, `ExecuteTool`, `ExecuteFlow`, `Run`, сетевые вызовы и т.п. — принимают `context.Context`.
    - Любой долгий процесс (HTTP, LLM, S3, WB) обязан уважать отмену контекста.

***

## Правила по ошибкам и логам

1. **Ошибки не «глотаются».**
    - Запрещено: игнорировать ошибки (`_ = err`) вне очевидных, локально обоснованных мест.
    - Обязателен `error wrapping`:
        - `fmt.Errorf("s3 load article %s: %w", articleID, err)`.
2. **Логирование только через общий интерфейс логгера.**
    - Никаких прямых вызовов `log.Printf` в бизнес‑коде.
    - Используется `interfaces.Logger` / `core.Logger`, передаваемый по зависимостям.
3. **UI‑вывод отделён от логов.**
    - Консольный UI пишет в `stdout`/`stderr`, но бизнес‑код не знает про формат UI.
    - Логи — структурированные, через логгер; UI‑строки — через отдельный слой.

***

## Правила по тестам и расширяемости

1. **Новый функционал — с точкой расширения, а не форком.**
    - Если нужно добавить модель/тул/флоу:
        - реализуется существующий интерфейс,
        - регистрируется через фабрику/реестр,
        - не ломает существующие контракты без крайней необходимости.[^10][^5]
2. **Тестируемость:**
    - Любая новая «единица архитектуры» (flow, UI‑компонент, cache, adapter):
        - должна иметь возможность быть протестированной с mock‑интерфейсами,
        - не должна тянуть за собой живые HTTP‑клиенты без опции подмены.
3. **Запрет на «god‑пакеты» (`common`, `utils`).**
    - Нельзя складывать всё подряд в общий `utils`/`common` без чёткой ответственности.
    - Если возникает желание так сделать — сначала уточнить ответственность и слой, куда это относится.[^2][^4]

***

## Практическое правило для любого нового кода

Перед тем как добавить новый файл/пакет, разработчик обязан ответить «да» на все вопросы:

1. Понимается ли однозначно, к какому слою относится новый код (core / model / tool / flow / cli / ui / infra)?[^11][^1]
2. Импортирует ли этот пакет зависимости только «вниз» по слоям, а не «вверх»?
3. Можно ли заменить конкретную реализацию (модель, тул, клиент) без изменений в более «высоких» слоях?
4. Можно ли протестировать компонент, подменив зависимости через интерфейсы?

Если хотя бы на один вопрос ответ «нет» — архитектура нарушена, такой PR не принимается до переделки.
